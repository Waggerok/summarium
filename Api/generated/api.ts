/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface BaseMessageResponse
 */
export interface BaseMessageResponse {
    /**
     *
     * @type {string}
     * @memberof BaseMessageResponse
     */
    'message': BaseMessageResponseMessageEnum;
}

export const BaseMessageResponseMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type BaseMessageResponseMessageEnum = typeof BaseMessageResponseMessageEnum[keyof typeof BaseMessageResponseMessageEnum];

/**
 *
 * @export
 * @interface BaseStatusResponse
 */
export interface BaseStatusResponse {
    /**
     *
     * @type {boolean}
     * @memberof BaseStatusResponse
     */
    'status': boolean;
}
/**
 *
 * @export
 * @interface CancelTaskResponse
 */
export interface CancelTaskResponse {
    /**
     *
     * @type {string}
     * @memberof CancelTaskResponse
     */
    'message': CancelTaskResponseMessageEnum;
}

export const CancelTaskResponseMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type CancelTaskResponseMessageEnum = typeof CancelTaskResponseMessageEnum[keyof typeof CancelTaskResponseMessageEnum];

/**
 *
 * @export
 * @interface ChangeEmailRequest
 */
export interface ChangeEmailRequest {
    /**
     *
     * @type {string}
     * @memberof ChangeEmailRequest
     */
    'email': string;
}
/**
 *
 * @export
 * @interface ChangeProfileInfoRequest
 */
export interface ChangeProfileInfoRequest {
    /**
     *
     * @type {number}
     * @memberof ChangeProfileInfoRequest
     */
    'available_seconds'?: number | null;
    /**
     *
     * @type {string}
     * @memberof ChangeProfileInfoRequest
     */
    'first_name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ChangeProfileInfoRequest
     */
    'middle_name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ChangeProfileInfoRequest
     */
    'last_name'?: string | null;
    /**
     *
     * @type {number}
     * @memberof ChangeProfileInfoRequest
     */
    'role_id'?: number | null;
}
/**
 *
 * @export
 * @interface ChangeUserRoleRequest
 */
export interface ChangeUserRoleRequest {
    /**
     *
     * @type {string}
     * @memberof ChangeUserRoleRequest
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof ChangeUserRoleRequest
     */
    'level'?: number | null;
}
/**
 *
 * @export
 * @interface CreateTaskRequest
 */
export interface CreateTaskRequest {
    /**
     *
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'project_id': string;
    /**
     *
     * @type {TaskType}
     * @memberof CreateTaskRequest
     */
    'task_type': TaskType;
    /**
     *
     * @type {Params}
     * @memberof CreateTaskRequest
     */
    'params': Params;
}


/**
 *
 * @export
 * @interface CreateTaskResponse
 */
export interface CreateTaskResponse {
    /**
     *
     * @type {string}
     * @memberof CreateTaskResponse
     */
    'message': CreateTaskResponseMessageEnum;
}

export const CreateTaskResponseMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type CreateTaskResponseMessageEnum = typeof CreateTaskResponseMessageEnum[keyof typeof CreateTaskResponseMessageEnum];

/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     *
     * @type {number}
     * @memberof CreateUserRequest
     */
    'role_id': number;
    /**
     *
     * @type {number}
     * @memberof CreateUserRequest
     */
    'available_seconds'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'first_name': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'middle_name': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'last_name'?: string | null;
}
/**
 *
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     *
     * @type {string}
     * @memberof CreateUserResponse
     */
    'login': string;
    /**
     *
     * @type {number}
     * @memberof CreateUserResponse
     */
    'telegram_id': number | null;
    /**
     *
     * @type {number}
     * @memberof CreateUserResponse
     */
    'available_seconds': number;
    /**
     *
     * @type {string}
     * @memberof CreateUserResponse
     */
    'user_role_name': string;
    /**
     *
     * @type {number}
     * @memberof CreateUserResponse
     */
    'user_access_level': number;
    /**
     *
     * @type {UserProfileInfoResponse}
     * @memberof CreateUserResponse
     */
    'profile_info': UserProfileInfoResponse | null;
    /**
     *
     * @type {string}
     * @memberof CreateUserResponse
     */
    'password'?: string | null;
}
/**
 *
 * @export
 * @interface CreateUserRoleRequest
 */
export interface CreateUserRoleRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserRoleRequest
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof CreateUserRoleRequest
     */
    'level'?: number | null;
}
/**
 *
 * @export
 * @interface DiarizationParams
 */
export interface DiarizationParams {
    /**
     *
     * @type {string}
     * @memberof DiarizationParams
     */
    'force_language'?: string | null;
    /**
     *
     * @type {number}
     * @memberof DiarizationParams
     */
    'batch_size'?: number | null;
    /**
     *
     * @type {boolean}
     * @memberof DiarizationParams
     */
    'suppress_numerals'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof DiarizationParams
     */
    'words_extended_information'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof DiarizationParams
     */
    'noise_reduction'?: boolean;
    /**
     *
     * @type {string}
     * @memberof DiarizationParams
     */
    'audio_type'?: string | null;
    /**
     *
     * @type {number}
     * @memberof DiarizationParams
     */
    'num_speakers'?: number | null;
    /**
     *
     * @type {boolean}
     * @memberof DiarizationParams
     */
    'demucs_enabled'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof DiarizationParams
     */
    'beautify_speakers_order'?: boolean;
}
/**
 *
 * @export
 * @interface FileMetaInformationRequest
 */
export interface FileMetaInformationRequest {
    /**
     * File content type (MIME-Type)
     * @type {string}
     * @memberof FileMetaInformationRequest
     */
    'content_type': string;
    /**
     * File content length (in bytes)
     * @type {number}
     * @memberof FileMetaInformationRequest
     */
    'content_length': number;
}
/**
 *
 * @export
 * @interface GenerateReportRequest
 */
export interface GenerateReportRequest {
    /**
     *
     * @type {boolean}
     * @memberof GenerateReportRequest
     */
    'time_marks'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GenerateReportRequest
     */
    'speakers_separation'?: boolean;
    /**
     *
     * @type {string}
     * @memberof GenerateReportRequest
     */
    'project_id': string;
    /**
     *
     * @type {ReportType}
     * @memberof GenerateReportRequest
     */
    'report_type': ReportType;
    /**
     *
     * @type {string}
     * @memberof GenerateReportRequest
     */
    'project_theme'?: string | null;
    /**
     *
     * @type {string}
     * @memberof GenerateReportRequest
     */
    'project_description'?: string | null;
}


/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     *
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Response model to validate and return when performing a health check.
 * @export
 * @interface HealthCheck
 */
export interface HealthCheck {
    /**
     *
     * @type {string}
     * @memberof HealthCheck
     */
    'message': HealthCheckMessageEnum;
}

export const HealthCheckMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type HealthCheckMessageEnum = typeof HealthCheckMessageEnum[keyof typeof HealthCheckMessageEnum];

/**
 *
 * @export
 * @interface LicenseInfoResponse
 */
export interface LicenseInfoResponse {
    /**
     *
     * @type {string}
     * @memberof LicenseInfoResponse
     */
    'license_type': string;
    /**
     *
     * @type {string}
     * @memberof LicenseInfoResponse
     */
    'activation_date': string;
    /**
     *
     * @type {string}
     * @memberof LicenseInfoResponse
     */
    'unique_id': string;
    /**
     *
     * @type {string}
     * @memberof LicenseInfoResponse
     */
    'license_number': string;
}
/**
 *
 * @export
 * @interface MassProjectsDeletionRequest
 */
export interface MassProjectsDeletionRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof MassProjectsDeletionRequest
     */
    'project_ids': Array<string>;
}
/**
 *
 * @export
 * @interface MassProjectsDeletionResponse
 */
export interface MassProjectsDeletionResponse {
    /**
     *
     * @type {string}
     * @memberof MassProjectsDeletionResponse
     */
    'message': MassProjectsDeletionResponseMessageEnum;
    /**
     *
     * @type {number}
     * @memberof MassProjectsDeletionResponse
     */
    'deleted': number;
    /**
     *
     * @type {number}
     * @memberof MassProjectsDeletionResponse
     */
    'error': number;
}

export const MassProjectsDeletionResponseMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type MassProjectsDeletionResponseMessageEnum = typeof MassProjectsDeletionResponseMessageEnum[keyof typeof MassProjectsDeletionResponseMessageEnum];

/**
 *
 * @export
 * @interface MassProjectsDownloadRequest
 */
export interface MassProjectsDownloadRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof MassProjectsDownloadRequest
     */
    'project_ids': Array<string>;
}
/**
 *
 * @export
 * @interface MassUsersDeletionRequest
 */
export interface MassUsersDeletionRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof MassUsersDeletionRequest
     */
    'user_logins': Array<string>;
}
/**
 *
 * @export
 * @interface MassUsersDeletionResponse
 */
export interface MassUsersDeletionResponse {
    /**
     *
     * @type {string}
     * @memberof MassUsersDeletionResponse
     */
    'message': MassUsersDeletionResponseMessageEnum;
    /**
     *
     * @type {number}
     * @memberof MassUsersDeletionResponse
     */
    'deleted': number;
    /**
     *
     * @type {number}
     * @memberof MassUsersDeletionResponse
     */
    'error': number;
}

export const MassUsersDeletionResponseMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type MassUsersDeletionResponseMessageEnum = typeof MassUsersDeletionResponseMessageEnum[keyof typeof MassUsersDeletionResponseMessageEnum];

/**
 *
 * @export
 * @interface OidcProviderResponse
 */
export interface OidcProviderResponse {
    /**
     *
     * @type {string}
     * @memberof OidcProviderResponse
     */
    'provider_id': string;
    /**
     *
     * @type {string}
     * @memberof OidcProviderResponse
     */
    'provider_name': string;
}
/**
 *
 * @export
 * @interface OptionalSentenceData
 */
export interface OptionalSentenceData {
    /**
     *
     * @type {number}
     * @memberof OptionalSentenceData
     */
    'speaker_id'?: number | null;
    /**
     *
     * @type {string}
     * @memberof OptionalSentenceData
     */
    'speaker_name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof OptionalSentenceData
     */
    'text'?: string | null;
    /**
     *
     * @type {number}
     * @memberof OptionalSentenceData
     */
    'start_millis': number;
    /**
     *
     * @type {number}
     * @memberof OptionalSentenceData
     */
    'end_millis': number;
    /**
     *
     * @type {Array<WordExtendedInfo>}
     * @memberof OptionalSentenceData
     */
    'words_extended_information'?: Array<WordExtendedInfo> | null;
}
/**
 *
 * @export
 * @interface OtaProject
 */
export interface OtaProject {
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'project_id': string;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'file_path': string;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'owner_username': string;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'name': string;
    /**
     *
     * @type {ProjectStatus}
     * @memberof OtaProject
     */
    'status': ProjectStatus;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'creation_date': string;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'updated_at': string;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'theme'?: string | null;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'description'?: string | null;
    /**
     *
     * @type {TranscriptionResult}
     * @memberof OtaProject
     */
    'transcription_result'?: TranscriptionResult | null;
    /**
     *
     * @type {ProjectMetaInformation}
     * @memberof OtaProject
     */
    'meta_information'?: ProjectMetaInformation | null;
    /**
     *
     * @type {string}
     * @memberof OtaProject
     */
    'resume_result'?: string | null;
    /**
     *
     * @type {TranscriptionResult}
     * @memberof OtaProject
     */
    'editable_transcription_result'?: TranscriptionResult | null;
    /**
     *
     * @type {number}
     * @memberof OtaProject
     */
    'position_in_queue'?: number | null;
}


/**
 *
 * @export
 * @interface PaginatedResponseRecentProject
 */
export interface PaginatedResponseRecentProject {
    /**
     *
     * @type {number}
     * @memberof PaginatedResponseRecentProject
     */
    'limit': number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponseRecentProject
     */
    'total_pages': number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponseRecentProject
     */
    'total_count': number;
    /**
     *
     * @type {Array<RecentProject>}
     * @memberof PaginatedResponseRecentProject
     */
    'objects': Array<RecentProject>;
}
/**
 *
 * @export
 * @interface PaginatedResponseUserResponse
 */
export interface PaginatedResponseUserResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedResponseUserResponse
     */
    'limit': number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponseUserResponse
     */
    'total_pages': number;
    /**
     *
     * @type {number}
     * @memberof PaginatedResponseUserResponse
     */
    'total_count': number;
    /**
     *
     * @type {Array<UserResponse>}
     * @memberof PaginatedResponseUserResponse
     */
    'objects': Array<UserResponse>;
}
/**
 *
 * @export
 * @interface Params
 */
export interface Params {
    /**
     *
     * @type {string}
     * @memberof Params
     */
    'force_language'?: string;
    /**
     *
     * @type {number}
     * @memberof Params
     */
    'batch_size'?: number;
    /**
     *
     * @type {boolean}
     * @memberof Params
     */
    'suppress_numerals'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Params
     */
    'words_extended_information'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Params
     */
    'noise_reduction'?: boolean;
    /**
     *
     * @type {string}
     * @memberof Params
     */
    'audio_type'?: string;
    /**
     *
     * @type {number}
     * @memberof Params
     */
    'num_speakers'?: number;
    /**
     *
     * @type {boolean}
     * @memberof Params
     */
    'demucs_enabled'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Params
     */
    'beautify_speakers_order'?: boolean;
    /**
     *
     * @type {SummarizationTemplateType}
     * @memberof Params
     */
    'template'?: SummarizationTemplateType;
}


/**
 *
 * @export
 * @interface ProjectMetaInformation
 */
export interface ProjectMetaInformation {
    /**
     *
     * @type {number}
     * @memberof ProjectMetaInformation
     */
    'file_duration_millis'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ProjectMetaInformation
     */
    'file_size_bytes'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ProjectMetaInformation
     */
    'task_duration_millis'?: number | null;
    /**
     *
     * @type {number}
     * @memberof ProjectMetaInformation
     */
    'words_count'?: number | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ProjectStatus = {
    Ok: 'OK',
    InProgress: 'IN_PROGRESS',
    SummarizationGenerating: 'SUMMARIZATION_GENERATING',
    Error: 'ERROR'
} as const;

export type ProjectStatus = typeof ProjectStatus[keyof typeof ProjectStatus];


/**
 *
 * @export
 * @interface RecentProject
 */
export interface RecentProject {
    /**
     *
     * @type {string}
     * @memberof RecentProject
     */
    'project_id': string;
    /**
     *
     * @type {string}
     * @memberof RecentProject
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof RecentProject
     */
    'theme'?: string | null;
    /**
     *
     * @type {string}
     * @memberof RecentProject
     */
    'description'?: string | null;
    /**
     *
     * @type {string}
     * @memberof RecentProject
     */
    'updated_at': string;
}
/**
 *
 * @export
 * @interface RenameProjectRequest
 */
export interface RenameProjectRequest {
    /**
     *
     * @type {string}
     * @memberof RenameProjectRequest
     */
    'name': string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ReportType = {
    Docx: 'docx',
    Json: 'json',
    Xml: 'xml',
    Srt: 'srt',
    Vtt: 'vtt',
    Txt: 'txt',
    Pdf: 'pdf',
    Clipboard: 'clipboard',
} as const;

export type ReportType = typeof ReportType[keyof typeof ReportType];


/**
 *
 * @export
 * @interface SaveProjectChangesRequest
 */
export interface SaveProjectChangesRequest {
    /**
     *
     * @type {string}
     * @memberof SaveProjectChangesRequest
     */
    'project_id': string;
    /**
     *
     * @type {string}
     * @memberof SaveProjectChangesRequest
     */
    'project_theme'?: string | null;
    /**
     *
     * @type {string}
     * @memberof SaveProjectChangesRequest
     */
    'project_description'?: string | null;
    /**
     *
     * @type {Array<OptionalSentenceData>}
     * @memberof SaveProjectChangesRequest
     */
    'sentences'?: Array<OptionalSentenceData>;
}
/**
 *
 * @export
 * @interface SaveProjectChangesResponse
 */
export interface SaveProjectChangesResponse {
    /**
     *
     * @type {string}
     * @memberof SaveProjectChangesResponse
     */
    'message': SaveProjectChangesResponseMessageEnum;
}

export const SaveProjectChangesResponseMessageEnum = {
    Ok: 'OK',
    PartialError: 'PARTIAL_ERROR',
    Error: 'ERROR'
} as const;

export type SaveProjectChangesResponseMessageEnum = typeof SaveProjectChangesResponseMessageEnum[keyof typeof SaveProjectChangesResponseMessageEnum];

/**
 *
 * @export
 * @interface SummarizationParams
 */
export interface SummarizationParams {
    /**
     *
     * @type {SummarizationTemplateType}
     * @memberof SummarizationParams
     */
    'template'?: SummarizationTemplateType;
}


/**
 *
 * @export
 * @enum {string}
 */

export const SummarizationTemplateType = {
    Report: 'report',
    Brief: 'brief',
    Abstract: 'abstract',
    Summary: 'summary'
} as const;

export type SummarizationTemplateType = typeof SummarizationTemplateType[keyof typeof SummarizationTemplateType];


/**
 *
 * @export
 * @enum {string}
 */

export const TaskType = {
    Transcribation: 'transcribation',
    Diarization: 'diarization',
    Summarization: 'summarization'
} as const;

export type TaskType = typeof TaskType[keyof typeof TaskType];


/**
 *
 * @export
 * @interface Token
 */
export interface Token {
    /**
     *
     * @type {string}
     * @memberof Token
     */
    'access_token': string;
    /**
     *
     * @type {string}
     * @memberof Token
     */
    'token_type': string;
}
/**
 *
 * @export
 * @interface TranscribeParams
 */
export interface TranscribeParams {
    /**
     *
     * @type {string}
     * @memberof TranscribeParams
     */
    'force_language'?: string | null;
    /**
     *
     * @type {number}
     * @memberof TranscribeParams
     */
    'batch_size'?: number | null;
    /**
     *
     * @type {boolean}
     * @memberof TranscribeParams
     */
    'suppress_numerals'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof TranscribeParams
     */
    'words_extended_information'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof TranscribeParams
     */
    'noise_reduction'?: boolean;
}
/**
 *
 * @export
 * @interface TranscriptionResult
 */
export interface TranscriptionResult {
    /**
     *
     * @type {string}
     * @memberof TranscriptionResult
     */
    'language_code': string;
    /**
     *
     * @type {Array<TranscriptionSegment>}
     * @memberof TranscriptionResult
     */
    'sentences': Array<TranscriptionSegment>;
}
/**
 *
 * @export
 * @interface TranscriptionSegment
 */
export interface TranscriptionSegment {
    /**
     *
     * @type {number}
     * @memberof TranscriptionSegment
     */
    'start_millis': number;
    /**
     *
     * @type {number}
     * @memberof TranscriptionSegment
     */
    'end_millis': number;
    /**
     *
     * @type {string}
     * @memberof TranscriptionSegment
     */
    'text': string;
    /**
     *
     * @type {number}
     * @memberof TranscriptionSegment
     */
    'speaker_id'?: number | null;
    /**
     *
     * @type {string}
     * @memberof TranscriptionSegment
     */
    'speaker_name'?: string | null;
    /**
     *
     * @type {Array<WordExtendedInfo>}
     * @memberof TranscriptionSegment
     */
    'words_extended_information'?: Array<WordExtendedInfo> | null;
}
/**
 * Password response  If password was sent to User Email password will be None
 * @export
 * @interface UserPasswordResponse
 */
export interface UserPasswordResponse {
    /**
     *
     * @type {string}
     * @memberof UserPasswordResponse
     */
    'password'?: string | null;
}
/**
 *
 * @export
 * @interface UserProfileInfoResponse
 */
export interface UserProfileInfoResponse {
    /**
     *
     * @type {string}
     * @memberof UserProfileInfoResponse
     */
    'first_name': string | null;
    /**
     *
     * @type {string}
     * @memberof UserProfileInfoResponse
     */
    'middle_name': string | null;
    /**
     *
     * @type {string}
     * @memberof UserProfileInfoResponse
     */
    'last_name': string | null;
    /**
     *
     * @type {string}
     * @memberof UserProfileInfoResponse
     */
    'full_name': string;
}
/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     *
     * @type {string}
     * @memberof UserResponse
     */
    'login': string;
    /**
     *
     * @type {number}
     * @memberof UserResponse
     */
    'telegram_id': number | null;
    /**
     *
     * @type {number}
     * @memberof UserResponse
     */
    'available_seconds': number;
    /**
     *
     * @type {string}
     * @memberof UserResponse
     */
    'user_role_name': string;
    /**
     *
     * @type {number}
     * @memberof UserResponse
     */
    'user_access_level': number;
    /**
     *
     * @type {UserProfileInfoResponse}
     * @memberof UserResponse
     */
    'profile_info': UserProfileInfoResponse | null;
}
/**
 *
 * @export
 * @interface UserRoleResponse
 */
export interface UserRoleResponse {
    /**
     *
     * @type {string}
     * @memberof UserRoleResponse
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof UserRoleResponse
     */
    'level'?: number | null;
    /**
     *
     * @type {number}
     * @memberof UserRoleResponse
     */
    'id'?: number | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     *
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     *
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     *
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * This structure describes information about single words (Info from Wav2Vec2 model)
 * @export
 * @interface WordExtendedInfo
 */
export interface WordExtendedInfo {
    /**
     *
     * @type {string}
     * @memberof WordExtendedInfo
     */
    'word': string;
    /**
     *
     * @type {number}
     * @memberof WordExtendedInfo
     */
    'start_millis': number;
    /**
     *
     * @type {number}
     * @memberof WordExtendedInfo
     */
    'end_millis': number;
    /**
     *
     * @type {number}
     * @memberof WordExtendedInfo
     */
    'accuracy': number;
    /**
     *
     * @type {number}
     * @memberof WordExtendedInfo
     */
    'speaker_id'?: number | null;
}

/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get Oidc Login Url
         * @param {string} providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet: async (providerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet', 'providerId', providerId)
            const localVarPath = `/api/auth/oidc/get_login_url/{provider_id}`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Oidc Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOidcProvidersApiAuthOidcProvidersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/oidc_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Login For Access Token
         * @param {string} userAgent
         * @param {string} username
         * @param {string} password
         * @param {string | null} [grantType]
         * @param {string} [scope]
         * @param {string | null} [clientId]
         * @param {string | null} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthLoginPost: async (userAgent: string, username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthLoginPost', 'userAgent', userAgent)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthLoginPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthLoginPost', 'password', password)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (username !== undefined) {
                localVarFormParams.set('username', username as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            if (scope !== undefined) {
                localVarFormParams.set('scope', scope as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret as any);
            }


            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Oidc Login By Token
         * @param {string} providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet: async (providerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet', 'providerId', providerId)
            const localVarPath = `/api/auth/oidc/login_by_token/{provider_id}`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get Oidc Login Url
         * @param {string} providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet(providerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet(providerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizationApi.getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get Oidc Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOidcProvidersApiAuthOidcProvidersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OidcProviderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOidcProvidersApiAuthOidcProvidersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizationApi.getOidcProvidersApiAuthOidcProvidersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Login For Access Token
         * @param {string} userAgent
         * @param {string} username
         * @param {string} password
         * @param {string | null} [grantType]
         * @param {string} [scope]
         * @param {string | null} [clientId]
         * @param {string | null} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForAccessTokenApiAuthLoginPost(userAgent: string, username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginForAccessTokenApiAuthLoginPost(userAgent, username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizationApi.loginForAccessTokenApiAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Oidc Login By Token
         * @param {string} providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet(providerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet(providerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizationApi.oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizationApiFp(configuration)
    return {
        /**
         *
         * @summary Get Oidc Login Url
         * @param {string} providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet(providerId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Oidc Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOidcProvidersApiAuthOidcProvidersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<OidcProviderResponse>> {
            return localVarFp.getOidcProvidersApiAuthOidcProvidersGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Login For Access Token
         * @param {string} userAgent
         * @param {string} username
         * @param {string} password
         * @param {string | null} [grantType]
         * @param {string} [scope]
         * @param {string | null} [clientId]
         * @param {string | null} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthLoginPost(userAgent: string, username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.loginForAccessTokenApiAuthLoginPost(userAgent, username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Oidc Login By Token
         * @param {string} providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet(providerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet(providerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     *
     * @summary Get Oidc Login Url
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet(providerId: string, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).getOidcLoginUrlApiAuthOidcGetLoginUrlProviderIdGet(providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get Oidc Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getOidcProvidersApiAuthOidcProvidersGet(options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).getOidcProvidersApiAuthOidcProvidersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Login For Access Token
     * @param {string} userAgent
     * @param {string} username
     * @param {string} password
     * @param {string | null} [grantType]
     * @param {string} [scope]
     * @param {string | null} [clientId]
     * @param {string | null} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public loginForAccessTokenApiAuthLoginPost(userAgent: string, username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).loginForAccessTokenApiAuthLoginPost(userAgent, username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Oidc Login By Token
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet(providerId: string, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).oidcLoginByTokenApiAuthOidcLoginByTokenProviderIdGet(providerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Perform a Health Check Endpoint to perform a healthcheck on. This endpoint can primarily be used Docker to ensure a robust container orchestration and management is in place. Other services which rely on proper functioning of the API service will not deploy if this endpoint returns any other HTTP status code except 200 (OK). Returns:     HealthCheck: Returns a JSON response with the health status
         * @summary Perform a Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthApiHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Perform a Health Check Endpoint to perform a healthcheck on. This endpoint can primarily be used Docker to ensure a robust container orchestration and management is in place. Other services which rely on proper functioning of the API service will not deploy if this endpoint returns any other HTTP status code except 200 (OK). Returns:     HealthCheck: Returns a JSON response with the health status
         * @summary Perform a Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthApiHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthApiHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthCheckApi.getHealthApiHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckApiFp(configuration)
    return {
        /**
         * ## Perform a Health Check Endpoint to perform a healthcheck on. This endpoint can primarily be used Docker to ensure a robust container orchestration and management is in place. Other services which rely on proper functioning of the API service will not deploy if this endpoint returns any other HTTP status code except 200 (OK). Returns:     HealthCheck: Returns a JSON response with the health status
         * @summary Perform a Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthApiHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheck> {
            return localVarFp.getHealthApiHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
    /**
     * ## Perform a Health Check Endpoint to perform a healthcheck on. This endpoint can primarily be used Docker to ensure a robust container orchestration and management is in place. Other services which rely on proper functioning of the API service will not deploy if this endpoint returns any other HTTP status code except 200 (OK). Returns:     HealthCheck: Returns a JSON response with the health status
     * @summary Perform a Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public getHealthApiHealthGet(options?: RawAxiosRequestConfig) {
        return HealthCheckApiFp(this.configuration).getHealthApiHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicenseInfoApi - axios parameter creator
 * @export
 */
export const LicenseInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get License Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseInfoApiLicenseGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/license/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseInfoApi - functional programming interface
 * @export
 */
export const LicenseInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseInfoApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get License Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseInfoApiLicenseGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseInfoApiLicenseGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseInfoApi.getLicenseInfoApiLicenseGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseInfoApi - factory interface
 * @export
 */
export const LicenseInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseInfoApiFp(configuration)
    return {
        /**
         *
         * @summary Get License Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseInfoApiLicenseGet(options?: RawAxiosRequestConfig): AxiosPromise<LicenseInfoResponse> {
            return localVarFp.getLicenseInfoApiLicenseGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseInfoApi - object-oriented interface
 * @export
 * @class LicenseInfoApi
 * @extends {BaseAPI}
 */
export class LicenseInfoApi extends BaseAPI {
    /**
     *
     * @summary Get License Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseInfoApi
     */
    public getLicenseInfoApiLicenseGet(options?: RawAxiosRequestConfig) {
        return LicenseInfoApiFp(this.configuration).getLicenseInfoApiLicenseGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Cancel Task
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTaskApiProjectCancelTaskProjectIdDelete: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('cancelTaskApiProjectCancelTaskProjectIdDelete', 'projectId', projectId)
            const localVarPath = `/api/project/cancel_task/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Task
         * @param {CreateTaskRequest} createTaskRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiProjectCreateTaskPost: async (createTaskRequest: CreateTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskRequest' is not null or undefined
            assertParamExists('createTaskApiProjectCreateTaskPost', 'createTaskRequest', createTaskRequest)
            const localVarPath = `/api/project/create_task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete User Project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProjectApiProjectProjectIdDelete: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteUserProjectApiProjectProjectIdDelete', 'projectId', projectId)
            const localVarPath = `/api/project/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Download Project File
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProjectFileApiProjectDownloadFileProjectIdGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('downloadProjectFileApiProjectDownloadFileProjectIdGet', 'projectId', projectId)
            const localVarPath = `/api/project/download_file/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Download Project Files
         * @param {MassProjectsDownloadRequest} massProjectsDownloadRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProjectFilesApiProjectMassDownloadProjectsPost: async (massProjectsDownloadRequest: MassProjectsDownloadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'massProjectsDownloadRequest' is not null or undefined
            assertParamExists('downloadProjectFilesApiProjectMassDownloadProjectsPost', 'massProjectsDownloadRequest', massProjectsDownloadRequest)
            const localVarPath = `/api/project/mass_download_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(massProjectsDownloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Project Audio File Peaks
         * @param {string} projectId
         * @param {number} [numPeaks]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet: async (projectId: string, numPeaks?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet', 'projectId', projectId)
            const localVarPath = `/api/project/get_peaks/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (numPeaks !== undefined) {
                localVarQueryParameter['num_peaks'] = numPeaks;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Recent Projects
         * @param {number} [limit]
         * @param {number} [page]
         * @param {string | null} [searchTerm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjectsApiProjectRecentProjectsGet: async (limit?: number, page?: number, searchTerm?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/project/recent_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get User Project
         * @param {string} projectId
         * @param {string | null} [lastUpdateTimestamp] Last project update time (In ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectApiProjectProjectIdGet: async (projectId: string, lastUpdateTimestamp?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getUserProjectApiProjectProjectIdGet', 'projectId', projectId)
            const localVarPath = `/api/project/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (lastUpdateTimestamp !== undefined) {
                localVarQueryParameter['last_update_timestamp'] = (lastUpdateTimestamp as any instanceof Date) ?
                    (lastUpdateTimestamp as any).toISOString() :
                    lastUpdateTimestamp;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Mass Delete Projects
         * @param {MassProjectsDeletionRequest} massProjectsDeletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        massDeleteProjectsApiProjectMassDeleteProjectsPost: async (massProjectsDeletionRequest: MassProjectsDeletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'massProjectsDeletionRequest' is not null or undefined
            assertParamExists('massDeleteProjectsApiProjectMassDeleteProjectsPost', 'massProjectsDeletionRequest', massProjectsDeletionRequest)
            const localVarPath = `/api/project/mass_delete_projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(massProjectsDeletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Rename Project
         * @param {string} projectId
         * @param {RenameProjectRequest} renameProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameProjectApiProjectRenameProjectIdPost: async (projectId: string, renameProjectRequest: RenameProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('renameProjectApiProjectRenameProjectIdPost', 'projectId', projectId)
            // verify required parameter 'renameProjectRequest' is not null or undefined
            assertParamExists('renameProjectApiProjectRenameProjectIdPost', 'renameProjectRequest', renameProjectRequest)
            const localVarPath = `/api/project/rename/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Save Project Changes
         * @param {SaveProjectChangesRequest} saveProjectChangesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProjectChangesApiProjectSaveChangesPost: async (saveProjectChangesRequest: SaveProjectChangesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveProjectChangesRequest' is not null or undefined
            assertParamExists('saveProjectChangesApiProjectSaveChangesPost', 'saveProjectChangesRequest', saveProjectChangesRequest)
            const localVarPath = `/api/project/save_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveProjectChangesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Cancel Task
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTaskApiProjectCancelTaskProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTaskApiProjectCancelTaskProjectIdDelete(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.cancelTaskApiProjectCancelTaskProjectIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create Task
         * @param {CreateTaskRequest} createTaskRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskApiProjectCreateTaskPost(createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskApiProjectCreateTaskPost(createTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.createTaskApiProjectCreateTaskPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete User Project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserProjectApiProjectProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserProjectApiProjectProjectIdDelete(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.deleteUserProjectApiProjectProjectIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Download Project File
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProjectFileApiProjectDownloadFileProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProjectFileApiProjectDownloadFileProjectIdGet(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.downloadProjectFileApiProjectDownloadFileProjectIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Download Project Files
         * @param {MassProjectsDownloadRequest} massProjectsDownloadRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProjectFilesApiProjectMassDownloadProjectsPost(massProjectsDownloadRequest: MassProjectsDownloadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProjectFilesApiProjectMassDownloadProjectsPost(massProjectsDownloadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.downloadProjectFilesApiProjectMassDownloadProjectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get Project Audio File Peaks
         * @param {string} projectId
         * @param {number} [numPeaks]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet(projectId: string, numPeaks?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet(projectId, numPeaks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get Recent Projects
         * @param {number} [limit]
         * @param {number} [page]
         * @param {string | null} [searchTerm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentProjectsApiProjectRecentProjectsGet(limit?: number, page?: number, searchTerm?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseRecentProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentProjectsApiProjectRecentProjectsGet(limit, page, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.getRecentProjectsApiProjectRecentProjectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get User Project
         * @param {string} projectId
         * @param {string | null} [lastUpdateTimestamp] Last project update time (In ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProjectApiProjectProjectIdGet(projectId: string, lastUpdateTimestamp?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OtaProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProjectApiProjectProjectIdGet(projectId, lastUpdateTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.getUserProjectApiProjectProjectIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Mass Delete Projects
         * @param {MassProjectsDeletionRequest} massProjectsDeletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async massDeleteProjectsApiProjectMassDeleteProjectsPost(massProjectsDeletionRequest: MassProjectsDeletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MassProjectsDeletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.massDeleteProjectsApiProjectMassDeleteProjectsPost(massProjectsDeletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.massDeleteProjectsApiProjectMassDeleteProjectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Rename Project
         * @param {string} projectId
         * @param {RenameProjectRequest} renameProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameProjectApiProjectRenameProjectIdPost(projectId: string, renameProjectRequest: RenameProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OtaProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameProjectApiProjectRenameProjectIdPost(projectId, renameProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.renameProjectApiProjectRenameProjectIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Save Project Changes
         * @param {SaveProjectChangesRequest} saveProjectChangesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProjectChangesApiProjectSaveChangesPost(saveProjectChangesRequest: SaveProjectChangesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveProjectChangesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProjectChangesApiProjectSaveChangesPost(saveProjectChangesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.saveProjectChangesApiProjectSaveChangesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         *
         * @summary Cancel Task
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTaskApiProjectCancelTaskProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CancelTaskResponse> {
            return localVarFp.cancelTaskApiProjectCancelTaskProjectIdDelete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Task
         * @param {CreateTaskRequest} createTaskRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskApiProjectCreateTaskPost(createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateTaskResponse> {
            return localVarFp.createTaskApiProjectCreateTaskPost(createTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete User Project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProjectApiProjectProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseMessageResponse> {
            return localVarFp.deleteUserProjectApiProjectProjectIdDelete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download Project File
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProjectFileApiProjectDownloadFileProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadProjectFileApiProjectDownloadFileProjectIdGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download Project Files
         * @param {MassProjectsDownloadRequest} massProjectsDownloadRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProjectFilesApiProjectMassDownloadProjectsPost(massProjectsDownloadRequest: MassProjectsDownloadRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadProjectFilesApiProjectMassDownloadProjectsPost(massProjectsDownloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Project Audio File Peaks
         * @param {string} projectId
         * @param {number} [numPeaks]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet(projectId: string, numPeaks?: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet(projectId, numPeaks, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Recent Projects
         * @param {number} [limit]
         * @param {number} [page]
         * @param {string | null} [searchTerm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProjectsApiProjectRecentProjectsGet(limit?: number, page?: number, searchTerm?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseRecentProject> {
            return localVarFp.getRecentProjectsApiProjectRecentProjectsGet(limit, page, searchTerm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get User Project
         * @param {string} projectId
         * @param {string | null} [lastUpdateTimestamp] Last project update time (In ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectApiProjectProjectIdGet(projectId: string, lastUpdateTimestamp?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<OtaProject> {
            return localVarFp.getUserProjectApiProjectProjectIdGet(projectId, lastUpdateTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Mass Delete Projects
         * @param {MassProjectsDeletionRequest} massProjectsDeletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        massDeleteProjectsApiProjectMassDeleteProjectsPost(massProjectsDeletionRequest: MassProjectsDeletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<MassProjectsDeletionResponse> {
            return localVarFp.massDeleteProjectsApiProjectMassDeleteProjectsPost(massProjectsDeletionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Rename Project
         * @param {string} projectId
         * @param {RenameProjectRequest} renameProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameProjectApiProjectRenameProjectIdPost(projectId: string, renameProjectRequest: RenameProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<OtaProject> {
            return localVarFp.renameProjectApiProjectRenameProjectIdPost(projectId, renameProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Save Project Changes
         * @param {SaveProjectChangesRequest} saveProjectChangesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProjectChangesApiProjectSaveChangesPost(saveProjectChangesRequest: SaveProjectChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<SaveProjectChangesResponse> {
            return localVarFp.saveProjectChangesApiProjectSaveChangesPost(saveProjectChangesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     *
     * @summary Cancel Task
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public cancelTaskApiProjectCancelTaskProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).cancelTaskApiProjectCancelTaskProjectIdDelete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create Task
     * @param {CreateTaskRequest} createTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createTaskApiProjectCreateTaskPost(createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createTaskApiProjectCreateTaskPost(createTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete User Project
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteUserProjectApiProjectProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteUserProjectApiProjectProjectIdDelete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Download Project File
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public downloadProjectFileApiProjectDownloadFileProjectIdGet(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).downloadProjectFileApiProjectDownloadFileProjectIdGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Download Project Files
     * @param {MassProjectsDownloadRequest} massProjectsDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public downloadProjectFilesApiProjectMassDownloadProjectsPost(massProjectsDownloadRequest: MassProjectsDownloadRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).downloadProjectFilesApiProjectMassDownloadProjectsPost(massProjectsDownloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get Project Audio File Peaks
     * @param {string} projectId
     * @param {number} [numPeaks]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet(projectId: string, numPeaks?: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjectAudioFilePeaksApiProjectGetPeaksProjectIdGet(projectId, numPeaks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get Recent Projects
     * @param {number} [limit]
     * @param {number} [page]
     * @param {string | null} [searchTerm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getRecentProjectsApiProjectRecentProjectsGet(limit?: number, page?: number, searchTerm?: string | null, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getRecentProjectsApiProjectRecentProjectsGet(limit, page, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get User Project
     * @param {string} projectId
     * @param {string | null} [lastUpdateTimestamp] Last project update time (In ISO format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getUserProjectApiProjectProjectIdGet(projectId: string, lastUpdateTimestamp?: string | null, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getUserProjectApiProjectProjectIdGet(projectId, lastUpdateTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Mass Delete Projects
     * @param {MassProjectsDeletionRequest} massProjectsDeletionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public massDeleteProjectsApiProjectMassDeleteProjectsPost(massProjectsDeletionRequest: MassProjectsDeletionRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).massDeleteProjectsApiProjectMassDeleteProjectsPost(massProjectsDeletionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Rename Project
     * @param {string} projectId
     * @param {RenameProjectRequest} renameProjectRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public renameProjectApiProjectRenameProjectIdPost(projectId: string, renameProjectRequest: RenameProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).renameProjectApiProjectRenameProjectIdPost(projectId, renameProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Save Project Changes
     * @param {SaveProjectChangesRequest} saveProjectChangesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public saveProjectChangesApiProjectSaveChangesPost(saveProjectChangesRequest: SaveProjectChangesRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).saveProjectChangesApiProjectSaveChangesPost(saveProjectChangesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Generate Report
         * @param {GenerateReportRequest} generateReportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReportApiReportsGenerateReportPost: async (generateReportRequest: GenerateReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateReportRequest' is not null or undefined
            assertParamExists('generateReportApiReportsGenerateReportPost', 'generateReportRequest', generateReportRequest)
            const localVarPath = `/api/reports/generate_report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Generate Report
         * @param {GenerateReportRequest} generateReportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateReportApiReportsGenerateReportPost(generateReportRequest: GenerateReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateReportApiReportsGenerateReportPost(generateReportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.generateReportApiReportsGenerateReportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         *
         * @summary Generate Report
         * @param {GenerateReportRequest} generateReportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReportApiReportsGenerateReportPost(generateReportRequest: GenerateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.generateReportApiReportsGenerateReportPost(generateReportRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     *
     * @summary Generate Report
     * @param {GenerateReportRequest} generateReportRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public generateReportApiReportsGenerateReportPost(generateReportRequest: GenerateReportRequest, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).generateReportApiReportsGenerateReportPost(generateReportRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if a file could be uploaded
         * @summary Could Upload
         * @param {FileMetaInformationRequest} fileMetaInformationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couldUploadApiUploadsCouldUploadPost: async (fileMetaInformationRequest: FileMetaInformationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileMetaInformationRequest' is not null or undefined
            assertParamExists('couldUploadApiUploadsCouldUploadPost', 'fileMetaInformationRequest', fileMetaInformationRequest)
            const localVarPath = `/api/uploads/could_upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileMetaInformationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload File
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileApiUploadsUploadFilePost: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFileApiUploadsUploadFilePost', 'file', file)
            const localVarPath = `/api/uploads/upload_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if a file could be uploaded
         * @summary Could Upload
         * @param {FileMetaInformationRequest} fileMetaInformationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couldUploadApiUploadsCouldUploadPost(fileMetaInformationRequest: FileMetaInformationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couldUploadApiUploadsCouldUploadPost(fileMetaInformationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.couldUploadApiUploadsCouldUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Upload File
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileApiUploadsUploadFilePost(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OtaProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileApiUploadsUploadFilePost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.uploadFileApiUploadsUploadFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * Check if a file could be uploaded
         * @summary Could Upload
         * @param {FileMetaInformationRequest} fileMetaInformationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couldUploadApiUploadsCouldUploadPost(fileMetaInformationRequest: FileMetaInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.couldUploadApiUploadsCouldUploadPost(fileMetaInformationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload File
         * @param {File} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileApiUploadsUploadFilePost(file: File, options?: RawAxiosRequestConfig): AxiosPromise<OtaProject> {
            return localVarFp.uploadFileApiUploadsUploadFilePost(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * Check if a file could be uploaded
     * @summary Could Upload
     * @param {FileMetaInformationRequest} fileMetaInformationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public couldUploadApiUploadsCouldUploadPost(fileMetaInformationRequest: FileMetaInformationRequest, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).couldUploadApiUploadsCouldUploadPost(fileMetaInformationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Upload File
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public uploadFileApiUploadsUploadFilePost(file: File, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).uploadFileApiUploadsUploadFilePost(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserRolesApi - axios parameter creator
 * @export
 */
export const UserRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create Role Endpoint
         * @param {CreateUserRoleRequest} createUserRoleRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleEndpointApiUserRolesPut: async (createUserRoleRequest: CreateUserRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRoleRequest' is not null or undefined
            assertParamExists('createRoleEndpointApiUserRolesPut', 'createUserRoleRequest', createUserRoleRequest)
            const localVarPath = `/api/user_roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Role Endpoint
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleEndpointApiUserRolesRoleIdDelete: async (roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRoleEndpointApiUserRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/api/user_roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Available Roles Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRolesEndpointApiUserRolesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user_roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Role Endpoint
         * @param {number} roleId
         * @param {ChangeUserRoleRequest} changeUserRoleRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleEndpointApiUserRolesRoleIdPost: async (roleId: number, changeUserRoleRequest: ChangeUserRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('updateRoleEndpointApiUserRolesRoleIdPost', 'roleId', roleId)
            // verify required parameter 'changeUserRoleRequest' is not null or undefined
            assertParamExists('updateRoleEndpointApiUserRolesRoleIdPost', 'changeUserRoleRequest', changeUserRoleRequest)
            const localVarPath = `/api/user_roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRolesApi - functional programming interface
 * @export
 */
export const UserRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRolesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create Role Endpoint
         * @param {CreateUserRoleRequest} createUserRoleRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleEndpointApiUserRolesPut(createUserRoleRequest: CreateUserRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleEndpointApiUserRolesPut(createUserRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserRolesApi.createRoleEndpointApiUserRolesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete Role Endpoint
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleEndpointApiUserRolesRoleIdDelete(roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleEndpointApiUserRolesRoleIdDelete(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserRolesApi.deleteRoleEndpointApiUserRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get Available Roles Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableRolesEndpointApiUserRolesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableRolesEndpointApiUserRolesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserRolesApi.getAvailableRolesEndpointApiUserRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update Role Endpoint
         * @param {number} roleId
         * @param {ChangeUserRoleRequest} changeUserRoleRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleEndpointApiUserRolesRoleIdPost(roleId: number, changeUserRoleRequest: ChangeUserRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleEndpointApiUserRolesRoleIdPost(roleId, changeUserRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserRolesApi.updateRoleEndpointApiUserRolesRoleIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserRolesApi - factory interface
 * @export
 */
export const UserRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRolesApiFp(configuration)
    return {
        /**
         *
         * @summary Create Role Endpoint
         * @param {CreateUserRoleRequest} createUserRoleRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleEndpointApiUserRolesPut(createUserRoleRequest: CreateUserRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.createRoleEndpointApiUserRolesPut(createUserRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Role Endpoint
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleEndpointApiUserRolesRoleIdDelete(roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseStatusResponse> {
            return localVarFp.deleteRoleEndpointApiUserRolesRoleIdDelete(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Available Roles Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRolesEndpointApiUserRolesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.getAvailableRolesEndpointApiUserRolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update Role Endpoint
         * @param {number} roleId
         * @param {ChangeUserRoleRequest} changeUserRoleRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleEndpointApiUserRolesRoleIdPost(roleId: number, changeUserRoleRequest: ChangeUserRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateRoleEndpointApiUserRolesRoleIdPost(roleId, changeUserRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserRolesApi - object-oriented interface
 * @export
 * @class UserRolesApi
 * @extends {BaseAPI}
 */
export class UserRolesApi extends BaseAPI {
    /**
     *
     * @summary Create Role Endpoint
     * @param {CreateUserRoleRequest} createUserRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRolesApi
     */
    public createRoleEndpointApiUserRolesPut(createUserRoleRequest: CreateUserRoleRequest, options?: RawAxiosRequestConfig) {
        return UserRolesApiFp(this.configuration).createRoleEndpointApiUserRolesPut(createUserRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete Role Endpoint
     * @param {number} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRolesApi
     */
    public deleteRoleEndpointApiUserRolesRoleIdDelete(roleId: number, options?: RawAxiosRequestConfig) {
        return UserRolesApiFp(this.configuration).deleteRoleEndpointApiUserRolesRoleIdDelete(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get Available Roles Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRolesApi
     */
    public getAvailableRolesEndpointApiUserRolesGet(options?: RawAxiosRequestConfig) {
        return UserRolesApiFp(this.configuration).getAvailableRolesEndpointApiUserRolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update Role Endpoint
     * @param {number} roleId
     * @param {ChangeUserRoleRequest} changeUserRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRolesApi
     */
    public updateRoleEndpointApiUserRolesRoleIdPost(roleId: number, changeUserRoleRequest: ChangeUserRoleRequest, options?: RawAxiosRequestConfig) {
        return UserRolesApiFp(this.configuration).updateRoleEndpointApiUserRolesRoleIdPost(roleId, changeUserRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Change Email
         * @param {string | null} login
         * @param {ChangeEmailRequest} changeEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailApiUsersChangeEmailLoginPost: async (login: string | null, changeEmailRequest: ChangeEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('changeEmailApiUsersChangeEmailLoginPost', 'login', login)
            // verify required parameter 'changeEmailRequest' is not null or undefined
            assertParamExists('changeEmailApiUsersChangeEmailLoginPost', 'changeEmailRequest', changeEmailRequest)
            const localVarPath = `/api/users/change_email/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Change Self Email
         * @param {ChangeEmailRequest} changeEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSelfEmailApiUsersChangeEmailPost: async (changeEmailRequest: ChangeEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeEmailRequest' is not null or undefined
            assertParamExists('changeSelfEmailApiUsersChangeEmailPost', 'changeEmailRequest', changeEmailRequest)
            const localVarPath = `/api/users/change_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Change Self Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSelfPasswordApiUsersChangePasswordPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Change Self Profile Info
         * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSelfProfileInfoApiUsersProfileInfoPost: async (changeProfileInfoRequest: ChangeProfileInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeProfileInfoRequest' is not null or undefined
            assertParamExists('changeSelfProfileInfoApiUsersProfileInfoPost', 'changeProfileInfoRequest', changeProfileInfoRequest)
            const localVarPath = `/api/users/profile_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeProfileInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Change User Password
         * @param {string | null} login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPasswordApiUsersChangePasswordLoginPost: async (login: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('changeUserPasswordApiUsersChangePasswordLoginPost', 'login', login)
            const localVarPath = `/api/users/change_password/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Change User Profile Info
         * @param {string | null} login
         * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserProfileInfoApiUsersProfileInfoLoginPost: async (login: string | null, changeProfileInfoRequest: ChangeProfileInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('changeUserProfileInfoApiUsersProfileInfoLoginPost', 'login', login)
            // verify required parameter 'changeProfileInfoRequest' is not null or undefined
            assertParamExists('changeUserProfileInfoApiUsersProfileInfoLoginPost', 'changeProfileInfoRequest', changeProfileInfoRequest)
            const localVarPath = `/api/users/profile_info/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeProfileInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create New User
         * @param {CreateUserRequest} createUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUserApiUsersPut: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createNewUserApiUsersPut', 'createUserRequest', createUserRequest)
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete User
         * @param {string} login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserApiUsersLoginDelete: async (login: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('deleteUserApiUsersLoginDelete', 'login', login)
            const localVarPath = `/api/users/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get All Users
         * @param {number} [limit]
         * @param {number} [page]
         * @param {string | null} [searchTerm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersApiUsersGet: async (limit?: number, page?: number, searchTerm?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['search_term'] = searchTerm;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Mass Delete Users
         * @param {MassUsersDeletionRequest} massUsersDeletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        massDeleteUsersApiUsersMassDeleteUsersPost: async (massUsersDeletionRequest: MassUsersDeletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'massUsersDeletionRequest' is not null or undefined
            assertParamExists('massDeleteUsersApiUsersMassDeleteUsersPost', 'massUsersDeletionRequest', massUsersDeletionRequest)
            const localVarPath = `/api/users/mass_delete_users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(massUsersDeletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Whoami
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoamiApiUsersWhoamiGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Change Email
         * @param {string | null} login
         * @param {ChangeEmailRequest} changeEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEmailApiUsersChangeEmailLoginPost(login: string | null, changeEmailRequest: ChangeEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEmailApiUsersChangeEmailLoginPost(login, changeEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeEmailApiUsersChangeEmailLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Change Self Email
         * @param {ChangeEmailRequest} changeEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeSelfEmailApiUsersChangeEmailPost(changeEmailRequest: ChangeEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeSelfEmailApiUsersChangeEmailPost(changeEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeSelfEmailApiUsersChangeEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Change Self Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeSelfPasswordApiUsersChangePasswordPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeSelfPasswordApiUsersChangePasswordPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeSelfPasswordApiUsersChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Change Self Profile Info
         * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeSelfProfileInfoApiUsersProfileInfoPost(changeProfileInfoRequest: ChangeProfileInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeSelfProfileInfoApiUsersProfileInfoPost(changeProfileInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeSelfProfileInfoApiUsersProfileInfoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Change User Password
         * @param {string | null} login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPasswordApiUsersChangePasswordLoginPost(login: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPasswordApiUsersChangePasswordLoginPost(login, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeUserPasswordApiUsersChangePasswordLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Change User Profile Info
         * @param {string | null} login
         * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserProfileInfoApiUsersProfileInfoLoginPost(login: string | null, changeProfileInfoRequest: ChangeProfileInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserProfileInfoApiUsersProfileInfoLoginPost(login, changeProfileInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.changeUserProfileInfoApiUsersProfileInfoLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create New User
         * @param {CreateUserRequest} createUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewUserApiUsersPut(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewUserApiUsersPut(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createNewUserApiUsersPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete User
         * @param {string} login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserApiUsersLoginDelete(login: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserApiUsersLoginDelete(login, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserApiUsersLoginDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get All Users
         * @param {number} [limit]
         * @param {number} [page]
         * @param {string | null} [searchTerm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersApiUsersGet(limit?: number, page?: number, searchTerm?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersApiUsersGet(limit, page, searchTerm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getAllUsersApiUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Mass Delete Users
         * @param {MassUsersDeletionRequest} massUsersDeletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async massDeleteUsersApiUsersMassDeleteUsersPost(massUsersDeletionRequest: MassUsersDeletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MassUsersDeletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.massDeleteUsersApiUsersMassDeleteUsersPost(massUsersDeletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.massDeleteUsersApiUsersMassDeleteUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Whoami
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoamiApiUsersWhoamiGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoamiApiUsersWhoamiGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.whoamiApiUsersWhoamiGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         *
         * @summary Change Email
         * @param {string | null} login
         * @param {ChangeEmailRequest} changeEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailApiUsersChangeEmailLoginPost(login: string | null, changeEmailRequest: ChangeEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.changeEmailApiUsersChangeEmailLoginPost(login, changeEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change Self Email
         * @param {ChangeEmailRequest} changeEmailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSelfEmailApiUsersChangeEmailPost(changeEmailRequest: ChangeEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.changeSelfEmailApiUsersChangeEmailPost(changeEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change Self Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSelfPasswordApiUsersChangePasswordPost(options?: RawAxiosRequestConfig): AxiosPromise<UserPasswordResponse> {
            return localVarFp.changeSelfPasswordApiUsersChangePasswordPost(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change Self Profile Info
         * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSelfProfileInfoApiUsersProfileInfoPost(changeProfileInfoRequest: ChangeProfileInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.changeSelfProfileInfoApiUsersProfileInfoPost(changeProfileInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change User Password
         * @param {string | null} login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPasswordApiUsersChangePasswordLoginPost(login: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserPasswordResponse> {
            return localVarFp.changeUserPasswordApiUsersChangePasswordLoginPost(login, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change User Profile Info
         * @param {string | null} login
         * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserProfileInfoApiUsersProfileInfoLoginPost(login: string | null, changeProfileInfoRequest: ChangeProfileInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.changeUserProfileInfoApiUsersProfileInfoLoginPost(login, changeProfileInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create New User
         * @param {CreateUserRequest} createUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUserApiUsersPut(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserResponse> {
            return localVarFp.createNewUserApiUsersPut(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete User
         * @param {string} login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserApiUsersLoginDelete(login: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseStatusResponse> {
            return localVarFp.deleteUserApiUsersLoginDelete(login, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get All Users
         * @param {number} [limit]
         * @param {number} [page]
         * @param {string | null} [searchTerm]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersApiUsersGet(limit?: number, page?: number, searchTerm?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseUserResponse> {
            return localVarFp.getAllUsersApiUsersGet(limit, page, searchTerm, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Mass Delete Users
         * @param {MassUsersDeletionRequest} massUsersDeletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        massDeleteUsersApiUsersMassDeleteUsersPost(massUsersDeletionRequest: MassUsersDeletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<MassUsersDeletionResponse> {
            return localVarFp.massDeleteUsersApiUsersMassDeleteUsersPost(massUsersDeletionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Whoami
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoamiApiUsersWhoamiGet(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.whoamiApiUsersWhoamiGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *
     * @summary Change Email
     * @param {string | null} login
     * @param {ChangeEmailRequest} changeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeEmailApiUsersChangeEmailLoginPost(login: string | null, changeEmailRequest: ChangeEmailRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeEmailApiUsersChangeEmailLoginPost(login, changeEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Change Self Email
     * @param {ChangeEmailRequest} changeEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeSelfEmailApiUsersChangeEmailPost(changeEmailRequest: ChangeEmailRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeSelfEmailApiUsersChangeEmailPost(changeEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Change Self Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeSelfPasswordApiUsersChangePasswordPost(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeSelfPasswordApiUsersChangePasswordPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Change Self Profile Info
     * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeSelfProfileInfoApiUsersProfileInfoPost(changeProfileInfoRequest: ChangeProfileInfoRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeSelfProfileInfoApiUsersProfileInfoPost(changeProfileInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Change User Password
     * @param {string | null} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserPasswordApiUsersChangePasswordLoginPost(login: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeUserPasswordApiUsersChangePasswordLoginPost(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Change User Profile Info
     * @param {string | null} login
     * @param {ChangeProfileInfoRequest} changeProfileInfoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserProfileInfoApiUsersProfileInfoLoginPost(login: string | null, changeProfileInfoRequest: ChangeProfileInfoRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeUserProfileInfoApiUsersProfileInfoLoginPost(login, changeProfileInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create New User
     * @param {CreateUserRequest} createUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createNewUserApiUsersPut(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createNewUserApiUsersPut(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete User
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserApiUsersLoginDelete(login: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserApiUsersLoginDelete(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get All Users
     * @param {number} [limit]
     * @param {number} [page]
     * @param {string | null} [searchTerm]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsersApiUsersGet(limit?: number, page?: number, searchTerm?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsersApiUsersGet(limit, page, searchTerm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Mass Delete Users
     * @param {MassUsersDeletionRequest} massUsersDeletionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public massDeleteUsersApiUsersMassDeleteUsersPost(massUsersDeletionRequest: MassUsersDeletionRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).massDeleteUsersApiUsersMassDeleteUsersPost(massUsersDeletionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Whoami
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public whoamiApiUsersWhoamiGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).whoamiApiUsersWhoamiGet(options).then((request) => request(this.axios, this.basePath));
    }
}



